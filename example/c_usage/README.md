# C Usage Example for h6xserial_idl

This directory contains a complete example demonstrating how to use C99 headers generated by `h6xserial_idl` for serializing and deserializing messages.

## Overview

The example shows:

- **Scalar messages**: Simple single-value messages (uint8, float32, etc.)
- **Array messages**: Variable-length arrays of primitives (char strings, float arrays, int16 arrays)
- **Struct messages**: Complex structured data with multiple fields and mixed endianness
- **Error handling**: Proper validation and error checking
- **Encoding/Decoding**: Converting between structured data and byte streams

## Files

| File | Description |
|------|-------------|
| `sensor_messages.json` | Message definitions in JSON intermediate format |
| `sensor_messages.h` | Generated C99 header (auto-generated) |
| `example.c` | Example program demonstrating all message types |
| `Makefile` | Build system for compiling and running the example |
| `README.md` | This file |

## Building and Running

### Prerequisites

- GCC or compatible C99 compiler
- Make
- Rust toolchain (for regenerating headers)

### Quick Start

```bash
# Build the example
make

# Run the example
make run

# Or build and run in one step
make test
```

### Regenerating the Header

If you modify `sensor_messages.json`, regenerate the header:

```bash
make regenerate
```

This will run `h6xserial_idl` to generate a new `sensor_messages.h` from the JSON definition.

### Cleaning Up

```bash
# Remove build artifacts
make clean

# Remove all generated files including header
make distclean
```

## Message Definitions

The example includes the following message types:

### Scalar Messages

- **ping** (packet_id: 0): Simple uint8 connectivity check
- **temperature** (packet_id: 20): Float32 temperature in Celsius (big-endian)
- **humidity** (packet_id: 22): Uint8 humidity percentage

### Array Messages

- **firmware_version** (packet_id: 4): Char array (up to 32 chars) for version strings
- **device_name** (packet_id: 14): Char array (up to 64 chars) for device names
- **multi_temperature** (packet_id: 21): Float32 array (up to 8 values, big-endian)
- **motor_speeds** (packet_id: 50): Int16 array (up to 4 values, little-endian)

### Struct Messages

- **sensor_data** (packet_id: 30): Combined sensor readings
  - `temperature` (float32, big-endian)
  - `humidity` (uint8)
  - `pressure` (uint32, big-endian)
  - `co2_level` (uint16, big-endian)

- **led_control** (packet_id: 40): RGB LED control
  - `led_id` (uint8)
  - `red` (uint8)
  - `green` (uint8)
  - `blue` (uint8)
  - `brightness` (uint8)

## API Usage

### Encoding Example

```c
#include "sensor_messages.h"

// Create and populate a message
h6xserial_msg_temperature_t temp = {0};
temp.value = 23.5f;

// Encode to byte buffer
uint8_t buffer[256];
size_t encoded_len = h6xserial_msg_temperature_encode(&temp, buffer, sizeof(buffer));

if (encoded_len > 0) {
    // Send buffer over serial/network
    send_data(buffer, encoded_len);
}
```

### Decoding Example

```c
#include "sensor_messages.h"

// Receive byte buffer
uint8_t buffer[256];
size_t received_len = receive_data(buffer, sizeof(buffer));

// Decode into message structure
h6xserial_msg_temperature_t temp = {0};
bool success = h6xserial_msg_temperature_decode(&temp, buffer, received_len);

if (success) {
    printf("Temperature: %.2f°C\n", temp.value);
}
```

### Array Message Example

```c
// Encode string array
h6xserial_msg_firmware_version_t fw = {0};
const char* version = "v1.2.3";
fw.length = strlen(version);
memcpy(fw.data, version, fw.length);

uint8_t buffer[256];
size_t len = h6xserial_msg_firmware_version_encode(&fw, buffer, sizeof(buffer));

// Decode
h6xserial_msg_firmware_version_t decoded_fw = {0};
if (h6xserial_msg_firmware_version_decode(&decoded_fw, buffer, len)) {
    printf("Version: %.*s\n", (int)decoded_fw.length, decoded_fw.data);
}
```

### Struct Message Example

```c
// Create complex sensor data
h6xserial_msg_sensor_data_t sensor = {0};
sensor.temperature = 25.3f;
sensor.humidity = 65;
sensor.pressure = 101325;
sensor.co2_level = 450;

// Encode
uint8_t buffer[256];
size_t len = h6xserial_msg_sensor_data_encode(&sensor, buffer, sizeof(buffer));

// Decode
h6xserial_msg_sensor_data_t decoded = {0};
if (h6xserial_msg_sensor_data_decode(&decoded, buffer, len)) {
    printf("Temp: %.1f°C, Humidity: %u%%, Pressure: %u Pa, CO2: %u ppm\n",
           decoded.temperature, decoded.humidity,
           decoded.pressure, decoded.co2_level);
}
```

## Generated API

For each message defined in the JSON, the following are generated:

### Constants

```c
#define H6XSERIAL_MSG_<MESSAGE>_PACKET_ID <id>
#define H6XSERIAL_MSG_<MESSAGE>_MAX_LENGTH <len>  // For arrays only
```

### Types

```c
typedef struct {
    // Message fields
} h6xserial_msg_<message>_t;
```

### Functions

```c
// Encode message to byte buffer
// Returns: number of bytes written, or 0 on error
size_t h6xserial_msg_<message>_encode(
    const h6xserial_msg_<message>_t *msg,
    uint8_t *out_buf,
    size_t out_len
);

// Decode message from byte buffer
// Returns: true on success, false on error
bool h6xserial_msg_<message>_decode(
    h6xserial_msg_<message>_t *msg,
    const uint8_t *data,
    size_t data_len
);
```

## Endianness

The generated code handles endianness conversion automatically:

- **Big-endian** fields use `h6xserial_write_*_be()` and `h6xserial_read_*_be()`
- **Little-endian** fields use `h6xserial_write_*_le()` and `h6xserial_read_*_le()`
- Single-byte types (char, int8, uint8) are endian-neutral

You can specify endianness in the JSON definition:

```json
{
    "temperature": {
        "packet_id": 20,
        "msg_type": "float32",
        "endianess": "big"
    }
}
```

## Error Handling

All generated functions perform validation:

- **Encode functions** return 0 on error:
  - NULL pointer arguments
  - Buffer too small
  - Array length exceeds maximum

- **Decode functions** return false on error:
  - NULL pointer arguments
  - Invalid data length
  - Array length exceeds maximum

Always check return values:

```c
size_t len = h6xserial_msg_temperature_encode(&temp, buffer, sizeof(buffer));
if (len == 0) {
    // Handle error
}

bool ok = h6xserial_msg_temperature_decode(&temp, buffer, len);
if (!ok) {
    // Handle error
}
```

## Integration with h6x_dynamic_serial_interface

These generated message definitions can be integrated with the [h6x_dynamic_serial_interface](https://github.com/HarvestX/h6x_dynamic_serial_interface) protocol for full packet-based communication with CRC validation.

Example integration:

```c
#include "sensor_messages.h"
#include "h6x_serial_protocol.h"

// Encode message
h6xserial_msg_temperature_t temp = {.value = 23.5f};
uint8_t payload[256];
size_t payload_len = h6xserial_msg_temperature_encode(&temp, payload, sizeof(payload));

// Create protocol packet
Packet pkt = init_packet();
pkt.client_id = 0x01;
pkt.mode = SERIAL_MODE_HOST;
pkt.command = H6XSERIAL_MSG_TEMPERATURE_PACKET_ID;  // Use generated packet ID
pkt.data_len = payload_len;
memcpy(pkt.data, payload, payload_len);

// Send packet with CRC
char send_buffer[256];
if (create_packet(&pkt, send_buffer)) {
    serial_write(send_buffer, pkt.data_len + ADDITIONAL_PACKET_LENGTH);
}
```

## Further Reading

- [h6xserial_idl Documentation](../../README_JA.md)
- [Protocol Specification](../../concept/protocol.md)
- [h6x_dynamic_serial_interface](https://github.com/HarvestX/h6x_dynamic_serial_interface)

## License

See the [LICENSE](../../LICENSE) file for details.
