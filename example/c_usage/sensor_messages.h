/*
 * Auto-generated by h6xserial_idl.
 * Source: ./sensor_messages.json
 * Protocol version: 1.0.0
 * Max address: 255
 */

#ifndef H6XSERIAL_GENERATED_MESSAGES_H
#define H6XSERIAL_GENERATED_MESSAGES_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

static inline void h6xserial_write_u16_le(uint16_t value, uint8_t *out) {
    out[0] = (uint8_t)(value & 0xFFu);
    out[1] = (uint8_t)((value >> 8) & 0xFFu);
}

static inline uint16_t h6xserial_read_u16_le(const uint8_t *in) {
    return (uint16_t)((uint16_t)in[0] | ((uint16_t)in[1] << 8));
}

static inline void h6xserial_write_u16_be(uint16_t value, uint8_t *out) {
    out[0] = (uint8_t)((value >> 8) & 0xFFu);
    out[1] = (uint8_t)(value & 0xFFu);
}

static inline uint16_t h6xserial_read_u16_be(const uint8_t *in) {
    return (uint16_t)(((uint16_t)in[0] << 8) | (uint16_t)in[1]);
}

static inline void h6xserial_write_u32_le(uint32_t value, uint8_t *out) {
    out[0] = (uint8_t)(value & 0xFFu);
    out[1] = (uint8_t)((value >> 8) & 0xFFu);
    out[2] = (uint8_t)((value >> 16) & 0xFFu);
    out[3] = (uint8_t)((value >> 24) & 0xFFu);
}

static inline uint32_t h6xserial_read_u32_le(const uint8_t *in) {
    return ((uint32_t)in[0]) |
           ((uint32_t)in[1] << 8) |
           ((uint32_t)in[2] << 16) |
           ((uint32_t)in[3] << 24);
}

static inline void h6xserial_write_u32_be(uint32_t value, uint8_t *out) {
    out[0] = (uint8_t)((value >> 24) & 0xFFu);
    out[1] = (uint8_t)((value >> 16) & 0xFFu);
    out[2] = (uint8_t)((value >> 8) & 0xFFu);
    out[3] = (uint8_t)(value & 0xFFu);
}

static inline uint32_t h6xserial_read_u32_be(const uint8_t *in) {
    return ((uint32_t)in[0] << 24) |
           ((uint32_t)in[1] << 16) |
           ((uint32_t)in[2] << 8) |
           ((uint32_t)in[3]);
}

static inline void h6xserial_write_u64_le(uint64_t value, uint8_t *out) {
    out[0] = (uint8_t)(value & 0xFFu);
    out[1] = (uint8_t)((value >> 8) & 0xFFu);
    out[2] = (uint8_t)((value >> 16) & 0xFFu);
    out[3] = (uint8_t)((value >> 24) & 0xFFu);
    out[4] = (uint8_t)((value >> 32) & 0xFFu);
    out[5] = (uint8_t)((value >> 40) & 0xFFu);
    out[6] = (uint8_t)((value >> 48) & 0xFFu);
    out[7] = (uint8_t)((value >> 56) & 0xFFu);
}

static inline uint64_t h6xserial_read_u64_le(const uint8_t *in) {
    return ((uint64_t)in[0]) |
           ((uint64_t)in[1] << 8) |
           ((uint64_t)in[2] << 16) |
           ((uint64_t)in[3] << 24) |
           ((uint64_t)in[4] << 32) |
           ((uint64_t)in[5] << 40) |
           ((uint64_t)in[6] << 48) |
           ((uint64_t)in[7] << 56);
}

static inline void h6xserial_write_u64_be(uint64_t value, uint8_t *out) {
    out[0] = (uint8_t)((value >> 56) & 0xFFu);
    out[1] = (uint8_t)((value >> 48) & 0xFFu);
    out[2] = (uint8_t)((value >> 40) & 0xFFu);
    out[3] = (uint8_t)((value >> 32) & 0xFFu);
    out[4] = (uint8_t)((value >> 24) & 0xFFu);
    out[5] = (uint8_t)((value >> 16) & 0xFFu);
    out[6] = (uint8_t)((value >> 8) & 0xFFu);
    out[7] = (uint8_t)(value & 0xFFu);
}

static inline uint64_t h6xserial_read_u64_be(const uint8_t *in) {
    return ((uint64_t)in[0] << 56) |
           ((uint64_t)in[1] << 48) |
           ((uint64_t)in[2] << 40) |
           ((uint64_t)in[3] << 32) |
           ((uint64_t)in[4] << 24) |
           ((uint64_t)in[5] << 16) |
           ((uint64_t)in[6] << 8) |
           ((uint64_t)in[7]);
}

static inline void h6xserial_write_f32_le(float value, uint8_t *out) {
    uint32_t u;
    memcpy(&u, &value, sizeof(uint32_t));
    h6xserial_write_u32_le(u, out);
}

static inline float h6xserial_read_f32_le(const uint8_t *in) {
    uint32_t u = h6xserial_read_u32_le(in);
    float f;
    memcpy(&f, &u, sizeof(float));
    return f;
}

static inline void h6xserial_write_f32_be(float value, uint8_t *out) {
    uint32_t u;
    memcpy(&u, &value, sizeof(uint32_t));
    h6xserial_write_u32_be(u, out);
}

static inline float h6xserial_read_f32_be(const uint8_t *in) {
    uint32_t u = h6xserial_read_u32_be(in);
    float f;
    memcpy(&f, &u, sizeof(float));
    return f;
}

static inline void h6xserial_write_f64_le(double value, uint8_t *out) {
    uint64_t u;
    memcpy(&u, &value, sizeof(uint64_t));
    h6xserial_write_u64_le(u, out);
}

static inline double h6xserial_read_f64_le(const uint8_t *in) {
    uint64_t u = h6xserial_read_u64_le(in);
    double f;
    memcpy(&f, &u, sizeof(double));
    return f;
}

static inline void h6xserial_write_f64_be(double value, uint8_t *out) {
    uint64_t u;
    memcpy(&u, &value, sizeof(uint64_t));
    h6xserial_write_u64_be(u, out);
}

static inline double h6xserial_read_f64_be(const uint8_t *in) {
    uint64_t u = h6xserial_read_u64_be(in);
    double f;
    memcpy(&f, &u, sizeof(double));
    return f;
}


/* Ping command for connectivity check */
#define H6XSERIAL_MSG_PING_PACKET_ID 0

typedef struct {
    uint8_t value;
} h6xserial_msg_ping_t;

static inline size_t h6xserial_msg_ping_encode(const h6xserial_msg_ping_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (out_len < 1) {
        return 0;
    }
    (out_buf)[0] = (uint8_t)(msg->value);
    return 1;
}

static inline bool h6xserial_msg_ping_decode(h6xserial_msg_ping_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len != 1) {
        return false;
    }
    msg->value = (uint8_t)((data)[0]);
    return true;
}


/* Firmware version string */
#define H6XSERIAL_MSG_FIRMWARE_VERSION_PACKET_ID 4
#define H6XSERIAL_MSG_FIRMWARE_VERSION_MAX_LENGTH 32

typedef struct {
    size_t length;
    char data[H6XSERIAL_MSG_FIRMWARE_VERSION_MAX_LENGTH];
} h6xserial_msg_firmware_version_t;

static inline size_t h6xserial_msg_firmware_version_encode(const h6xserial_msg_firmware_version_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (msg->length > H6XSERIAL_MSG_FIRMWARE_VERSION_MAX_LENGTH) {
        return 0;
    }
    size_t required = msg->length * 1;
    if (out_len < required) {
        return 0;
    }
    if (required > 0) {
        memcpy(out_buf, msg->data, required);
    }
    return required;
}

static inline bool h6xserial_msg_firmware_version_decode(h6xserial_msg_firmware_version_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len % 1 != 0) {
        return false;
    }
    size_t element_count = data_len / 1;
    if (element_count > H6XSERIAL_MSG_FIRMWARE_VERSION_MAX_LENGTH) {
        return false;
    }
    msg->length = element_count;
    if (element_count == 0) {
        if (H6XSERIAL_MSG_FIRMWARE_VERSION_MAX_LENGTH > 0) {
            msg->data[0] = '\0';
        }
        return true;
    }
    memcpy(msg->data, data, element_count);
    if (element_count < H6XSERIAL_MSG_FIRMWARE_VERSION_MAX_LENGTH) {
        msg->data[element_count] = '\0';
    }
    return true;
}


/* Device name string */
#define H6XSERIAL_MSG_DEVICE_NAME_PACKET_ID 14
#define H6XSERIAL_MSG_DEVICE_NAME_MAX_LENGTH 64

typedef struct {
    size_t length;
    char data[H6XSERIAL_MSG_DEVICE_NAME_MAX_LENGTH];
} h6xserial_msg_device_name_t;

static inline size_t h6xserial_msg_device_name_encode(const h6xserial_msg_device_name_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (msg->length > H6XSERIAL_MSG_DEVICE_NAME_MAX_LENGTH) {
        return 0;
    }
    size_t required = msg->length * 1;
    if (out_len < required) {
        return 0;
    }
    if (required > 0) {
        memcpy(out_buf, msg->data, required);
    }
    return required;
}

static inline bool h6xserial_msg_device_name_decode(h6xserial_msg_device_name_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len % 1 != 0) {
        return false;
    }
    size_t element_count = data_len / 1;
    if (element_count > H6XSERIAL_MSG_DEVICE_NAME_MAX_LENGTH) {
        return false;
    }
    msg->length = element_count;
    if (element_count == 0) {
        if (H6XSERIAL_MSG_DEVICE_NAME_MAX_LENGTH > 0) {
            msg->data[0] = '\0';
        }
        return true;
    }
    memcpy(msg->data, data, element_count);
    if (element_count < H6XSERIAL_MSG_DEVICE_NAME_MAX_LENGTH) {
        msg->data[element_count] = '\0';
    }
    return true;
}


/* Single temperature reading in Celsius */
#define H6XSERIAL_MSG_TEMPERATURE_PACKET_ID 20

typedef struct {
    float value;
} h6xserial_msg_temperature_t;

static inline size_t h6xserial_msg_temperature_encode(const h6xserial_msg_temperature_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (out_len < 4) {
        return 0;
    }
    h6xserial_write_f32_be(msg->value, out_buf);
    return 4;
}

static inline bool h6xserial_msg_temperature_decode(h6xserial_msg_temperature_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len != 4) {
        return false;
    }
    msg->value = h6xserial_read_f32_be(data);
    return true;
}


/* Multiple temperature readings from sensors */
#define H6XSERIAL_MSG_MULTI_TEMPERATURE_PACKET_ID 21
#define H6XSERIAL_MSG_MULTI_TEMPERATURE_MAX_LENGTH 8

typedef struct {
    size_t length;
    float data[H6XSERIAL_MSG_MULTI_TEMPERATURE_MAX_LENGTH];
} h6xserial_msg_multi_temperature_t;

static inline size_t h6xserial_msg_multi_temperature_encode(const h6xserial_msg_multi_temperature_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (msg->length > H6XSERIAL_MSG_MULTI_TEMPERATURE_MAX_LENGTH) {
        return 0;
    }
    size_t required = msg->length * 4;
    if (out_len < required) {
        return 0;
    }
    size_t offset = 0;
    for (size_t i = 0; i < msg->length; ++i) {
        h6xserial_write_f32_be(msg->data[i], out_buf + offset);
        offset += 4;
    }
    return offset;
}

static inline bool h6xserial_msg_multi_temperature_decode(h6xserial_msg_multi_temperature_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len % 4 != 0) {
        return false;
    }
    size_t element_count = data_len / 4;
    if (element_count > H6XSERIAL_MSG_MULTI_TEMPERATURE_MAX_LENGTH) {
        return false;
    }
    msg->length = element_count;
    if (element_count == 0) {
        return true;
    }
    size_t offset = 0;
    for (size_t i = 0; i < element_count; ++i) {
        msg->data[i] = h6xserial_read_f32_be(data + offset);
        offset += 4;
    }
    return true;
}


/* Humidity reading in percentage (0-100) */
#define H6XSERIAL_MSG_HUMIDITY_PACKET_ID 22

typedef struct {
    uint8_t value;
} h6xserial_msg_humidity_t;

static inline size_t h6xserial_msg_humidity_encode(const h6xserial_msg_humidity_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (out_len < 1) {
        return 0;
    }
    (out_buf)[0] = (uint8_t)(msg->value);
    return 1;
}

static inline bool h6xserial_msg_humidity_decode(h6xserial_msg_humidity_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len != 1) {
        return false;
    }
    msg->value = (uint8_t)((data)[0]);
    return true;
}


/* Combined sensor data structure */
#define H6XSERIAL_MSG_SENSOR_DATA_PACKET_ID 30

#define H6XSERIAL_MSG_SENSOR_DATA_ROOM_B_TEMPERATURES_MAX_LENGTH 5
typedef struct {
    size_t temperatures_length;
    float temperatures[H6XSERIAL_MSG_SENSOR_DATA_ROOM_B_TEMPERATURES_MAX_LENGTH];
    uint8_t humidity;
    uint32_t pressure;
    uint16_t co2_level;
} h6xserial_msg_sensor_data_room_b_t;

typedef struct {
    float temperature;
    uint8_t humidity;
    uint32_t pressure;
    uint16_t co2_level;
    h6xserial_msg_sensor_data_room_b_t room_b;
} h6xserial_msg_sensor_data_t;

static inline size_t h6xserial_msg_sensor_data_encode(const h6xserial_msg_sensor_data_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (out_len < 38) {
        return 0;
    }
    size_t offset = 0;
    h6xserial_write_f32_be(msg->temperature, out_buf + offset);
    offset += 4;
    (out_buf + offset)[0] = (uint8_t)(msg->humidity);
    offset += 1;
    h6xserial_write_u32_be((uint32_t)(msg->pressure), out_buf + offset);
    offset += 4;
    h6xserial_write_u16_be((uint16_t)(msg->co2_level), out_buf + offset);
    offset += 2;
    for (size_t i = 0; i < msg->room_b.temperatures_length && i < H6XSERIAL_MSG_SENSOR_DATA_ROOM_B_TEMPERATURES_MAX_LENGTH; ++i) {
        h6xserial_write_f32_be(msg->room_b.temperatures[i], out_buf + offset);
        offset += 4;
    }
    (out_buf + offset)[0] = (uint8_t)(msg->room_b.humidity);
    offset += 1;
    h6xserial_write_u32_be((uint32_t)(msg->room_b.pressure), out_buf + offset);
    offset += 4;
    h6xserial_write_u16_be((uint16_t)(msg->room_b.co2_level), out_buf + offset);
    offset += 2;
    return offset;
}

static inline bool h6xserial_msg_sensor_data_decode(h6xserial_msg_sensor_data_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len < 18) {
        return false;
    }
    if (data_len > 38) {
        return false;
    }
    size_t offset = 0;
    size_t remaining = data_len;
    remaining -= 18;
    msg->temperature = h6xserial_read_f32_be(data + offset);
    offset += 4;
    msg->humidity = (uint8_t)((data + offset)[0]);
    offset += 1;
    msg->pressure = h6xserial_read_u32_be(data + offset);
    offset += 4;
    msg->co2_level = h6xserial_read_u16_be(data + offset);
    offset += 2;
    {
        size_t elem_count = remaining / 4;
        if (elem_count > H6XSERIAL_MSG_SENSOR_DATA_ROOM_B_TEMPERATURES_MAX_LENGTH) {
            elem_count = H6XSERIAL_MSG_SENSOR_DATA_ROOM_B_TEMPERATURES_MAX_LENGTH;
        }
        msg->room_b.temperatures_length = elem_count;
        for (size_t i = 0; i < elem_count; ++i) {
            msg->room_b.temperatures[i] = h6xserial_read_f32_be(data + offset);
            offset += 4;
        }
    }
    msg->room_b.humidity = (uint8_t)((data + offset)[0]);
    offset += 1;
    msg->room_b.pressure = h6xserial_read_u32_be(data + offset);
    offset += 4;
    msg->room_b.co2_level = h6xserial_read_u16_be(data + offset);
    offset += 2;
    return true;
}


/* RGB LED control message */
#define H6XSERIAL_MSG_LED_CONTROL_PACKET_ID 40

typedef struct {
    uint8_t led_id;
    uint8_t red;
    uint8_t green;
    uint8_t blue;
    uint8_t brightness;
} h6xserial_msg_led_control_t;

static inline size_t h6xserial_msg_led_control_encode(const h6xserial_msg_led_control_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (out_len < 5) {
        return 0;
    }
    size_t offset = 0;
    (out_buf + offset)[0] = (uint8_t)(msg->led_id);
    offset += 1;
    (out_buf + offset)[0] = (uint8_t)(msg->red);
    offset += 1;
    (out_buf + offset)[0] = (uint8_t)(msg->green);
    offset += 1;
    (out_buf + offset)[0] = (uint8_t)(msg->blue);
    offset += 1;
    (out_buf + offset)[0] = (uint8_t)(msg->brightness);
    offset += 1;
    return offset;
}

static inline bool h6xserial_msg_led_control_decode(h6xserial_msg_led_control_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len != 5) {
        return false;
    }
    size_t offset = 0;
    msg->led_id = (uint8_t)((data + offset)[0]);
    offset += 1;
    msg->red = (uint8_t)((data + offset)[0]);
    offset += 1;
    msg->green = (uint8_t)((data + offset)[0]);
    offset += 1;
    msg->blue = (uint8_t)((data + offset)[0]);
    offset += 1;
    msg->brightness = (uint8_t)((data + offset)[0]);
    offset += 1;
    return true;
}


/* Motor speed values (-32768 to 32767) */
#define H6XSERIAL_MSG_MOTOR_SPEEDS_PACKET_ID 50
#define H6XSERIAL_MSG_MOTOR_SPEEDS_MAX_LENGTH 4

typedef struct {
    size_t length;
    int16_t data[H6XSERIAL_MSG_MOTOR_SPEEDS_MAX_LENGTH];
} h6xserial_msg_motor_speeds_t;

static inline size_t h6xserial_msg_motor_speeds_encode(const h6xserial_msg_motor_speeds_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (msg->length > H6XSERIAL_MSG_MOTOR_SPEEDS_MAX_LENGTH) {
        return 0;
    }
    size_t required = msg->length * 2;
    if (out_len < required) {
        return 0;
    }
    size_t offset = 0;
    for (size_t i = 0; i < msg->length; ++i) {
        h6xserial_write_u16_le((uint16_t)(msg->data[i]), out_buf + offset);
        offset += 2;
    }
    return offset;
}

static inline bool h6xserial_msg_motor_speeds_decode(h6xserial_msg_motor_speeds_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len % 2 != 0) {
        return false;
    }
    size_t element_count = data_len / 2;
    if (element_count > H6XSERIAL_MSG_MOTOR_SPEEDS_MAX_LENGTH) {
        return false;
    }
    msg->length = element_count;
    if (element_count == 0) {
        return true;
    }
    size_t offset = 0;
    for (size_t i = 0; i < element_count; ++i) {
        msg->data[i] = (int16_t)h6xserial_read_u16_le(data + offset);
        offset += 2;
    }
    return true;
}


/* Large data */
#define H6XSERIAL_MSG_LARGE_DATA_PACKET_ID 60

#define H6XSERIAL_MSG_LARGE_DATA_DATA_MAX_LENGTH 108
typedef struct {
    uint8_t segment;
    size_t data_length;
    uint16_t data[H6XSERIAL_MSG_LARGE_DATA_DATA_MAX_LENGTH];
} h6xserial_msg_large_data_t;

static inline size_t h6xserial_msg_large_data_encode(const h6xserial_msg_large_data_t *msg, uint8_t *out_buf, const size_t out_len) {
    if (!msg || !out_buf) {
        return 0;
    }
    if (out_len < 217) {
        return 0;
    }
    size_t offset = 0;
    (out_buf + offset)[0] = (uint8_t)(msg->segment);
    offset += 1;
    for (size_t i = 0; i < msg->data_length && i < H6XSERIAL_MSG_LARGE_DATA_DATA_MAX_LENGTH; ++i) {
        h6xserial_write_u16_le((uint16_t)(msg->data[i]), out_buf + offset);
        offset += 2;
    }
    return offset;
}

static inline bool h6xserial_msg_large_data_decode(h6xserial_msg_large_data_t *msg, const uint8_t *data, const size_t data_len) {
    if (!msg || !data) {
        return false;
    }
    if (data_len < 1) {
        return false;
    }
    if (data_len > 217) {
        return false;
    }
    size_t offset = 0;
    size_t remaining = data_len;
    remaining -= 1;
    msg->segment = (uint8_t)((data + offset)[0]);
    offset += 1;
    {
        size_t elem_count = remaining / 2;
        if (elem_count > H6XSERIAL_MSG_LARGE_DATA_DATA_MAX_LENGTH) {
            elem_count = H6XSERIAL_MSG_LARGE_DATA_DATA_MAX_LENGTH;
        }
        msg->data_length = elem_count;
        for (size_t i = 0; i < elem_count; ++i) {
            msg->data[i] = h6xserial_read_u16_le(data + offset);
            offset += 2;
        }
    }
    return true;
}


#ifdef __cplusplus
}
#endif

#endif /* H6XSERIAL_GENERATED_MESSAGES_H */
