//! C99 code generator for message definitions.
//!
//! Generates header files with type definitions and encode/decode functions.

use std::fmt::Write as FmtWrite;
use std::path::Path;

use anyhow::Result;

use crate::{
    ArraySpec, Endian, MessageBody, MessageDefinition, Metadata, PrimitiveType, ScalarSpec,
    StructField, StructFieldType, StructSpec, TargetLanguage, load_templates, to_macro_ident,
    to_snake_case,
};

/// Template files containing C helper functions for serialization.
const TEMPLATE_FILES: &[&str] = &[
    "helpers_u16.h",
    "helpers_u32.h",
    "helpers_u64.h",
    "helpers_f32.h",
    "helpers_f64.h",
];

/// Generates C99 header code for the given message definitions.
///
/// # Arguments
/// * `metadata` - Protocol metadata (version, max_address)
/// * `messages` - List of message definitions to generate code for
/// * `input_path` - Path to input JSON file (for documentation)
/// * `output_path` - Path to output header file (for header guard)
///
/// # Returns
/// * `Ok(String)` - Generated C99 header code
/// * `Err(...)` - Generation error with context
///
/// # Generated Code
/// - Header guard based on output filename
/// - Type definitions for each message
/// - Encode functions returning bytes written
/// - Decode functions returning success/failure
/// - Packet ID constants
pub fn generate(
    metadata: &Metadata,
    messages: &[MessageDefinition],
    input_path: &Path,
    output_path: &Path,
) -> Result<String> {
    let helper_block = load_templates(TargetLanguage::C, TEMPLATE_FILES)?;
    let header_guard = header_guard_name(output_path);

    let mut out = String::new();
    writeln!(&mut out, "/*").unwrap();
    writeln!(&mut out, " * Auto-generated by h6xserial_idl.").unwrap();
    writeln!(&mut out, " * Source: {}", input_path.display()).unwrap();
    if let Some(version) = &metadata.version {
        writeln!(&mut out, " * Protocol version: {}", version).unwrap();
    }
    if let Some(max_address) = metadata.max_address {
        writeln!(&mut out, " * Max address: {}", max_address).unwrap();
    }
    writeln!(&mut out, " */\n").unwrap();

    writeln!(&mut out, "#ifndef {}", header_guard).unwrap();
    writeln!(&mut out, "#define {}\n", header_guard).unwrap();

    out.push_str(
        "#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n",
    );

    out.push_str("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
    out.push_str(&helper_block);

    for msg in messages {
        out.push('\n');
        out.push_str(&generate_message_block(msg));
    }

    out.push_str("\n#ifdef __cplusplus\n}\n#endif\n\n");
    writeln!(&mut out, "#endif /* {} */", header_guard).unwrap();

    Ok(out)
}

fn generate_message_block(msg: &MessageDefinition) -> String {
    let mut out = String::new();
    if let Some(desc) = &msg.description {
        writeln!(&mut out, "/* {} */", desc).unwrap();
    }
    let macro_prefix = to_macro_ident(&msg.name);
    writeln!(
        &mut out,
        "#define H6XSERIAL_MSG_{}_PACKET_ID {}",
        macro_prefix, msg.packet_id
    )
    .unwrap();

    match &msg.body {
        MessageBody::Array(spec) => {
            writeln!(
                &mut out,
                "#define H6XSERIAL_MSG_{}_MAX_LENGTH {}",
                macro_prefix, spec.max_length
            )
            .unwrap();
            if let Some(sector) = spec.sector_bytes {
                writeln!(
                    &mut out,
                    "#define H6XSERIAL_MSG_{}_SECTOR_BYTES {}",
                    macro_prefix, sector
                )
                .unwrap();
            }
            out.push('\n');
            out.push_str(&generate_array_block(msg, spec));
        }
        MessageBody::Scalar(spec) => {
            out.push('\n');
            out.push_str(&generate_scalar_block(msg, spec));
        }
        MessageBody::Struct(spec) => {
            out.push('\n');
            out.push_str(&generate_struct_block(msg, spec));
        }
    }

    out
}

fn generate_scalar_block(msg: &MessageDefinition, spec: &ScalarSpec) -> String {
    let mut out = String::new();
    let type_name = type_name(msg);
    let encode_name = encode_fn_name(msg);
    let decode_name = decode_fn_name(msg);

    writeln!(
        &mut out,
        "typedef struct {{\n    {} value;\n}} {};\n",
        spec.primitive.c_type(),
        type_name
    )
    .unwrap();

    let size = spec.primitive.byte_len();
    writeln!(
        &mut out,
        "static inline size_t {}(const {} *msg, uint8_t *out_buf, const size_t out_len) {{",
        encode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !out_buf) {\n        return 0;\n    }\n");
    writeln!(
        &mut out,
        "    if (out_len < {}) {{\n        return 0;\n    }}",
        size
    )
    .unwrap();
    out.push_str(&primitive_encode_stmt(
        spec.primitive,
        spec.endian,
        "msg->value",
        "out_buf",
        "    ",
    ));
    writeln!(&mut out, "    return {};\n}}\n", size).unwrap();

    writeln!(
        &mut out,
        "static inline bool {}({} *msg, const uint8_t *data, const size_t data_len) {{",
        decode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !data) {\n        return false;\n    }\n");
    writeln!(
        &mut out,
        "    if (data_len != {}) {{\n        return false;\n    }}",
        size
    )
    .unwrap();
    out.push_str(&primitive_decode_stmt(
        spec.primitive,
        spec.endian,
        "msg->value",
        "data",
        "    ",
    ));
    out.push_str("    return true;\n}\n\n");

    out
}

fn generate_array_block(msg: &MessageDefinition, spec: &ArraySpec) -> String {
    let mut out = String::new();
    let type_name = type_name(msg);
    let encode_name = encode_fn_name(msg);
    let decode_name = decode_fn_name(msg);
    let macro_prefix = to_macro_ident(&msg.name);
    let max_macro = format!("H6XSERIAL_MSG_{}_MAX_LENGTH", macro_prefix);

    writeln!(
        &mut out,
        "typedef struct {{\n    size_t length;\n    {} data[{}];\n}} {};\n",
        spec.primitive.c_type(),
        max_macro,
        type_name
    )
    .unwrap();

    let elem_size = spec.primitive.byte_len();
    writeln!(
        &mut out,
        "static inline size_t {}(const {} *msg, uint8_t *out_buf, const size_t out_len) {{",
        encode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !out_buf) {\n        return 0;\n    }\n");
    writeln!(
        &mut out,
        "    if (msg->length > {}) {{\n        return 0;\n    }}",
        max_macro
    )
    .unwrap();
    writeln!(
        &mut out,
        "    size_t required = msg->length * {};",
        elem_size
    )
    .unwrap();
    out.push_str("    if (out_len < required) {\n        return 0;\n    }\n");
    if elem_size == 1 {
        out.push_str(
            "    if (required > 0) {\n        memcpy(out_buf, msg->data, required);\n    }\n",
        );
        out.push_str("    return required;\n}\n\n");
    } else {
        out.push_str("    size_t offset = 0;\n    for (size_t i = 0; i < msg->length; ++i) {\n");
        out.push_str(&primitive_encode_stmt(
            spec.primitive,
            spec.endian,
            "msg->data[i]",
            "out_buf + offset",
            "        ",
        ));
        writeln!(&mut out, "        offset += {};", elem_size).unwrap();
        out.push_str("    }\n    return offset;\n}\n\n");
    }

    writeln!(
        &mut out,
        "static inline bool {}({} *msg, const uint8_t *data, const size_t data_len) {{",
        decode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !data) {\n        return false;\n    }\n");
    writeln!(
        &mut out,
        "    if (data_len % {} != 0) {{\n        return false;\n    }}",
        elem_size
    )
    .unwrap();
    writeln!(
        &mut out,
        "    size_t element_count = data_len / {};",
        elem_size
    )
    .unwrap();
    writeln!(
        &mut out,
        "    if (element_count > {}) {{\n        return false;\n    }}",
        max_macro
    )
    .unwrap();
    out.push_str("    msg->length = element_count;\n");
    out.push_str("    if (element_count == 0) {\n");
    if spec.primitive == PrimitiveType::Char {
        out.push_str("        if (");
        out.push_str(&max_macro);
        out.push_str(" > 0) {\n            msg->data[0] = '\\0';\n        }\n");
    }
    out.push_str("        return true;\n    }\n");
    if elem_size == 1 {
        out.push_str("    memcpy(msg->data, data, element_count);\n");
    } else {
        out.push_str("    size_t offset = 0;\n    for (size_t i = 0; i < element_count; ++i) {\n");
        out.push_str(&primitive_decode_stmt(
            spec.primitive,
            spec.endian,
            "msg->data[i]",
            "data + offset",
            "        ",
        ));
        writeln!(&mut out, "        offset += {};", elem_size).unwrap();
        out.push_str("    }\n");
    }
    if spec.primitive == PrimitiveType::Char {
        out.push_str("    if (element_count < ");
        out.push_str(&max_macro);
        out.push_str(") {\n        msg->data[element_count] = '\\0';\n    }\n");
    }
    out.push_str("    return true;\n}\n\n");

    out
}

/// Calculates the total byte size of a struct field (recursively for nested structs).
fn field_byte_len(field: &StructField) -> usize {
    match &field.field_type {
        StructFieldType::Primitive(prim) => prim.byte_len(),
        StructFieldType::Nested(nested) => struct_byte_len(nested),
    }
}

/// Calculates the total byte size of a struct (recursively for nested structs).
fn struct_byte_len(spec: &StructSpec) -> usize {
    spec.fields.iter().map(field_byte_len).sum()
}

/// Generates a nested struct type name.
fn nested_struct_type_name(parent_type_name: &str, field_name: &str) -> String {
    format!("{}_{}_t", parent_type_name.trim_end_matches("_t"), to_snake_case(field_name))
}

/// Generates typedef for a struct, including nested struct typedefs.
fn generate_struct_typedef(
    out: &mut String,
    type_name: &str,
    spec: &StructSpec,
) {
    // First, generate typedefs for any nested structs
    for field in &spec.fields {
        if let StructFieldType::Nested(nested_spec) = &field.field_type {
            let nested_type = nested_struct_type_name(type_name, &field.name);
            generate_struct_typedef(out, &nested_type, nested_spec);
        }
    }

    // Then generate this struct's typedef
    writeln!(out, "typedef struct {{").unwrap();
    for field in &spec.fields {
        let field_ident = to_snake_case(&field.name);
        let c_type = match &field.field_type {
            StructFieldType::Primitive(prim) => prim.c_type().to_string(),
            StructFieldType::Nested(_) => nested_struct_type_name(type_name, &field.name),
        };
        writeln!(out, "    {} {};", c_type, field_ident).unwrap();
    }
    writeln!(out, "}} {};\n", type_name).unwrap();
}

/// Generates encode statements for struct fields (recursively for nested structs).
fn generate_field_encode_stmts(
    out: &mut String,
    fields: &[StructField],
    parent_accessor: &str,
    indent: &str,
) {
    for field in fields {
        let field_ident = to_snake_case(&field.name);
        let accessor = format!("{}{}", parent_accessor, field_ident);
        match field.field_type {
            StructFieldType::Primitive(prim) => {
                out.push_str(&primitive_encode_stmt(
                    prim,
                    field.endian,
                    &accessor,
                    "out_buf + offset",
                    indent,
                ));
                writeln!(out, "{}offset += {};", indent, prim.byte_len()).unwrap();
            }
            StructFieldType::Nested(ref nested_spec) => {
                // Recursively encode nested struct fields
                let nested_accessor = format!("{}.", accessor);
                generate_field_encode_stmts(out, &nested_spec.fields, &nested_accessor, indent);
            }
        }
    }
}

/// Generates decode statements for struct fields (recursively for nested structs).
fn generate_field_decode_stmts(
    out: &mut String,
    fields: &[StructField],
    parent_accessor: &str,
    indent: &str,
) {
    for field in fields {
        let field_ident = to_snake_case(&field.name);
        let accessor = format!("{}{}", parent_accessor, field_ident);
        match field.field_type {
            StructFieldType::Primitive(prim) => {
                out.push_str(&primitive_decode_stmt(
                    prim,
                    field.endian,
                    &accessor,
                    "data + offset",
                    indent,
                ));
                writeln!(out, "{}offset += {};", indent, prim.byte_len()).unwrap();
            }
            StructFieldType::Nested(ref nested_spec) => {
                // Recursively decode nested struct fields
                let nested_accessor = format!("{}.", accessor);
                generate_field_decode_stmts(out, &nested_spec.fields, &nested_accessor, indent);
            }
        }
    }
}

fn generate_struct_block(msg: &MessageDefinition, spec: &StructSpec) -> String {
    let mut out = String::new();
    let type_name = type_name(msg);
    let encode_name = encode_fn_name(msg);
    let decode_name = decode_fn_name(msg);

    // Generate typedef(s) for struct and nested structs
    generate_struct_typedef(&mut out, &type_name, spec);

    let total_size = struct_byte_len(spec);

    writeln!(
        &mut out,
        "static inline size_t {}(const {} *msg, uint8_t *out_buf, const size_t out_len) {{",
        encode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !out_buf) {\n        return 0;\n    }\n");
    writeln!(
        &mut out,
        "    if (out_len < {}) {{\n        return 0;\n    }}",
        total_size
    )
    .unwrap();
    out.push_str("    size_t offset = 0;\n");
    generate_field_encode_stmts(&mut out, &spec.fields, "msg->", "    ");
    out.push_str("    return offset;\n}\n\n");

    writeln!(
        &mut out,
        "static inline bool {}({} *msg, const uint8_t *data, const size_t data_len) {{",
        decode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !data) {\n        return false;\n    }\n");
    writeln!(
        &mut out,
        "    if (data_len != {}) {{\n        return false;\n    }}",
        total_size
    )
    .unwrap();
    out.push_str("    size_t offset = 0;\n");
    generate_field_decode_stmts(&mut out, &spec.fields, "msg->", "    ");
    out.push_str("    return true;\n}\n\n");

    out
}

fn primitive_encode_stmt(
    primitive: PrimitiveType,
    endian: Endian,
    source: &str,
    dest_ptr: &str,
    indent: &str,
) -> String {
    match primitive {
        PrimitiveType::Char | PrimitiveType::Int8 | PrimitiveType::Uint8 => format!(
            "{indent}({dest})[0] = (uint8_t)({src});\n",
            indent = indent,
            dest = dest_ptr,
            src = source
        ),
        PrimitiveType::Int16 => format!(
            "{indent}h6xserial_write_u16_{suffix}((uint16_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Uint16 => format!(
            "{indent}h6xserial_write_u16_{suffix}((uint16_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Int32 => format!(
            "{indent}h6xserial_write_u32_{suffix}((uint32_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Uint32 => format!(
            "{indent}h6xserial_write_u32_{suffix}((uint32_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Int64 => format!(
            "{indent}h6xserial_write_u64_{suffix}((uint64_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Uint64 => format!(
            "{indent}h6xserial_write_u64_{suffix}((uint64_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Float32 => format!(
            "{indent}h6xserial_write_f32_{suffix}({src}, {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Float64 => format!(
            "{indent}h6xserial_write_f64_{suffix}({src}, {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
    }
}

fn primitive_decode_stmt(
    primitive: PrimitiveType,
    endian: Endian,
    dest: &str,
    src_ptr: &str,
    indent: &str,
) -> String {
    match primitive {
        PrimitiveType::Char => format!(
            "{indent}{dest} = (char)(({src})[0]);\n",
            indent = indent,
            dest = dest,
            src = src_ptr
        ),
        PrimitiveType::Int8 => format!(
            "{indent}{dest} = (int8_t)(({src})[0]);\n",
            indent = indent,
            dest = dest,
            src = src_ptr
        ),
        PrimitiveType::Uint8 => format!(
            "{indent}{dest} = (uint8_t)(({src})[0]);\n",
            indent = indent,
            dest = dest,
            src = src_ptr
        ),
        PrimitiveType::Int16 => format!(
            "{indent}{dest} = (int16_t)h6xserial_read_u16_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Uint16 => format!(
            "{indent}{dest} = h6xserial_read_u16_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Int32 => format!(
            "{indent}{dest} = (int32_t)h6xserial_read_u32_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Uint32 => format!(
            "{indent}{dest} = h6xserial_read_u32_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Int64 => format!(
            "{indent}{dest} = (int64_t)h6xserial_read_u64_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Uint64 => format!(
            "{indent}{dest} = h6xserial_read_u64_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Float32 => format!(
            "{indent}{dest} = h6xserial_read_f32_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Float64 => format!(
            "{indent}{dest} = h6xserial_read_f64_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
    }
}

fn type_name(msg: &MessageDefinition) -> String {
    format!("h6xserial_msg_{}_t", to_snake_case(&msg.name))
}

fn encode_fn_name(msg: &MessageDefinition) -> String {
    format!("h6xserial_msg_{}_encode", to_snake_case(&msg.name))
}

fn decode_fn_name(msg: &MessageDefinition) -> String {
    format!("h6xserial_msg_{}_decode", to_snake_case(&msg.name))
}

fn header_guard_name(path: &Path) -> String {
    let file_name = path
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("generated_header");
    let mut guard = String::new();
    for ch in file_name.chars() {
        if ch.is_ascii_alphanumeric() {
            guard.push(ch.to_ascii_uppercase());
        } else {
            guard.push('_');
        }
    }
    if !guard.ends_with("_H") {
        if !guard.ends_with('_') {
            guard.push('_');
        }
        guard.push('H');
    }
    guard
}
