use std::fmt::Write as FmtWrite;
use std::path::Path;

use anyhow::Result;

use crate::{
    ArraySpec, Endian, MessageBody, MessageDefinition, Metadata, PrimitiveType, ScalarSpec,
    StructSpec, TargetLanguage, load_templates, to_macro_ident, to_snake_case,
};

const TEMPLATE_FILES: &[&str] = &[
    "helpers_u16.h",
    "helpers_u32.h",
    "helpers_u64.h",
    "helpers_f32.h",
    "helpers_f64.h",
];

pub fn generate(
    metadata: &Metadata,
    messages: &[MessageDefinition],
    input_path: &Path,
    output_path: &Path,
) -> Result<String> {
    let helper_block = load_templates(TargetLanguage::C, TEMPLATE_FILES)?;
    let header_guard = header_guard_name(output_path);

    let mut out = String::new();
    writeln!(&mut out, "/*").unwrap();
    writeln!(&mut out, " * Auto-generated by h6xserial_idl.").unwrap();
    writeln!(&mut out, " * Source: {}", input_path.display()).unwrap();
    if let Some(version) = &metadata.version {
        writeln!(&mut out, " * Protocol version: {}", version).unwrap();
    }
    if let Some(max_address) = metadata.max_address {
        writeln!(&mut out, " * Max address: {}", max_address).unwrap();
    }
    writeln!(&mut out, " */\n").unwrap();

    writeln!(&mut out, "#ifndef {}", header_guard).unwrap();
    writeln!(&mut out, "#define {}\n", header_guard).unwrap();

    out.push_str(
        "#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n",
    );

    out.push_str("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
    out.push_str(&helper_block);

    for msg in messages {
        out.push('\n');
        out.push_str(&generate_message_block(msg));
    }

    out.push_str("\n#ifdef __cplusplus\n}\n#endif\n\n");
    writeln!(&mut out, "#endif /* {} */", header_guard).unwrap();

    Ok(out)
}

fn generate_message_block(msg: &MessageDefinition) -> String {
    let mut out = String::new();
    if let Some(desc) = &msg.description {
        writeln!(&mut out, "/* {} */", desc).unwrap();
    }
    let macro_prefix = to_macro_ident(&msg.name);
    writeln!(
        &mut out,
        "#define SERIDL_MSG_{}_PACKET_ID {}",
        macro_prefix, msg.packet_id
    )
    .unwrap();

    match &msg.body {
        MessageBody::Array(spec) => {
            writeln!(
                &mut out,
                "#define SERIDL_MSG_{}_MAX_LENGTH {}",
                macro_prefix, spec.max_length
            )
            .unwrap();
            if let Some(sector) = spec.sector_bytes {
                writeln!(
                    &mut out,
                    "#define SERIDL_MSG_{}_SECTOR_BYTES {}",
                    macro_prefix, sector
                )
                .unwrap();
            }
            out.push('\n');
            out.push_str(&generate_array_block(msg, spec));
        }
        MessageBody::Scalar(spec) => {
            out.push('\n');
            out.push_str(&generate_scalar_block(msg, spec));
        }
        MessageBody::Struct(spec) => {
            out.push('\n');
            out.push_str(&generate_struct_block(msg, spec));
        }
    }

    out
}

fn generate_scalar_block(msg: &MessageDefinition, spec: &ScalarSpec) -> String {
    let mut out = String::new();
    let type_name = type_name(msg);
    let encode_name = encode_fn_name(msg);
    let decode_name = decode_fn_name(msg);

    writeln!(
        &mut out,
        "typedef struct {{\n    {} value;\n}} {};\n",
        spec.primitive.c_type(),
        type_name
    )
    .unwrap();

    let size = spec.primitive.byte_len();
    writeln!(
        &mut out,
        "static inline size_t {}(const {} *msg, uint8_t *out_buf, size_t out_len) {{",
        encode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !out_buf) {\n        return 0;\n    }\n");
    writeln!(
        &mut out,
        "    if (out_len < {}) {{\n        return 0;\n    }}",
        size
    )
    .unwrap();
    out.push_str(&primitive_encode_stmt(
        spec.primitive,
        spec.endian,
        "msg->value",
        "out_buf",
        "    ",
    ));
    writeln!(&mut out, "    return {};\n}}\n", size).unwrap();

    writeln!(
        &mut out,
        "static inline bool {}({} *msg, const uint8_t *data, size_t data_len) {{",
        decode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !data) {\n        return false;\n    }\n");
    writeln!(
        &mut out,
        "    if (data_len != {}) {{\n        return false;\n    }}",
        size
    )
    .unwrap();
    out.push_str(&primitive_decode_stmt(
        spec.primitive,
        spec.endian,
        "msg->value",
        "data",
        "    ",
    ));
    out.push_str("    return true;\n}\n\n");

    out
}

fn generate_array_block(msg: &MessageDefinition, spec: &ArraySpec) -> String {
    let mut out = String::new();
    let type_name = type_name(msg);
    let encode_name = encode_fn_name(msg);
    let decode_name = decode_fn_name(msg);
    let macro_prefix = to_macro_ident(&msg.name);
    let max_macro = format!("SERIDL_MSG_{}_MAX_LENGTH", macro_prefix);

    writeln!(
        &mut out,
        "typedef struct {{\n    size_t length;\n    {} data[{}];\n}} {};\n",
        spec.primitive.c_type(),
        max_macro,
        type_name
    )
    .unwrap();

    let elem_size = spec.primitive.byte_len();
    writeln!(
        &mut out,
        "static inline size_t {}(const {} *msg, uint8_t *out_buf, size_t out_len) {{",
        encode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !out_buf) {\n        return 0;\n    }\n");
    writeln!(
        &mut out,
        "    if (msg->length > {}) {{\n        return 0;\n    }}",
        max_macro
    )
    .unwrap();
    writeln!(
        &mut out,
        "    size_t required = msg->length * {};",
        elem_size
    )
    .unwrap();
    out.push_str("    if (out_len < required) {\n        return 0;\n    }\n");
    if elem_size == 1 {
        out.push_str(
            "    if (required > 0) {\n        memcpy(out_buf, msg->data, required);\n    }\n",
        );
        out.push_str("    return required;\n}\n\n");
    } else {
        out.push_str("    size_t offset = 0;\n    for (size_t i = 0; i < msg->length; ++i) {\n");
        out.push_str(&primitive_encode_stmt(
            spec.primitive,
            spec.endian,
            "msg->data[i]",
            "out_buf + offset",
            "        ",
        ));
        writeln!(&mut out, "        offset += {};", elem_size).unwrap();
        out.push_str("    }\n    return offset;\n}\n\n");
    }

    writeln!(
        &mut out,
        "static inline bool {}({} *msg, const uint8_t *data, size_t data_len) {{",
        decode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !data) {\n        return false;\n    }\n");
    writeln!(
        &mut out,
        "    if (data_len % {} != 0) {{\n        return false;\n    }}",
        elem_size
    )
    .unwrap();
    writeln!(
        &mut out,
        "    size_t element_count = data_len / {};",
        elem_size
    )
    .unwrap();
    writeln!(
        &mut out,
        "    if (element_count > {}) {{\n        return false;\n    }}",
        max_macro
    )
    .unwrap();
    out.push_str("    msg->length = element_count;\n");
    out.push_str("    if (element_count == 0) {\n");
    if spec.primitive == PrimitiveType::Char {
        out.push_str("        if (");
        out.push_str(&max_macro);
        out.push_str(" > 0) {\n            msg->data[0] = '\\0';\n        }\n");
    }
    out.push_str("        return true;\n    }\n");
    if elem_size == 1 {
        out.push_str("    memcpy(msg->data, data, element_count);\n");
    } else {
        out.push_str("    size_t offset = 0;\n    for (size_t i = 0; i < element_count; ++i) {\n");
        out.push_str(&primitive_decode_stmt(
            spec.primitive,
            spec.endian,
            "msg->data[i]",
            "data + offset",
            "        ",
        ));
        writeln!(&mut out, "        offset += {};", elem_size).unwrap();
        out.push_str("    }\n");
    }
    if spec.primitive == PrimitiveType::Char {
        out.push_str("    if (element_count < ");
        out.push_str(&max_macro);
        out.push_str(") {\n        msg->data[element_count] = '\\0';\n    }\n");
    }
    out.push_str("    return true;\n}\n\n");

    out
}

fn generate_struct_block(msg: &MessageDefinition, spec: &StructSpec) -> String {
    let mut out = String::new();
    let type_name = type_name(msg);
    let encode_name = encode_fn_name(msg);
    let decode_name = decode_fn_name(msg);

    writeln!(&mut out, "typedef struct {{").unwrap();
    for field in &spec.fields {
        let field_ident = to_snake_case(&field.name);
        writeln!(
            &mut out,
            "    {} {};",
            field.primitive.c_type(),
            field_ident
        )
        .unwrap();
    }
    writeln!(&mut out, "}} {};\n", type_name).unwrap();

    let total_size: usize = spec.fields.iter().map(|f| f.primitive.byte_len()).sum();

    writeln!(
        &mut out,
        "static inline size_t {}(const {} *msg, uint8_t *out_buf, size_t out_len) {{",
        encode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !out_buf) {\n        return 0;\n    }\n");
    writeln!(
        &mut out,
        "    if (out_len < {}) {{\n        return 0;\n    }}",
        total_size
    )
    .unwrap();
    out.push_str("    size_t offset = 0;\n");
    for field in &spec.fields {
        let field_ident = to_snake_case(&field.name);
        out.push_str(&primitive_encode_stmt(
            field.primitive,
            field.endian,
            &format!("msg->{}", field_ident),
            "out_buf + offset",
            "    ",
        ));
        writeln!(&mut out, "    offset += {};", field.primitive.byte_len()).unwrap();
    }
    out.push_str("    return offset;\n}\n\n");

    writeln!(
        &mut out,
        "static inline bool {}({} *msg, const uint8_t *data, size_t data_len) {{",
        decode_name, type_name
    )
    .unwrap();
    out.push_str("    if (!msg || !data) {\n        return false;\n    }\n");
    writeln!(
        &mut out,
        "    if (data_len != {}) {{\n        return false;\n    }}",
        total_size
    )
    .unwrap();
    out.push_str("    size_t offset = 0;\n");
    for field in &spec.fields {
        let field_ident = to_snake_case(&field.name);
        out.push_str(&primitive_decode_stmt(
            field.primitive,
            field.endian,
            &format!("msg->{}", field_ident),
            "data + offset",
            "    ",
        ));
        writeln!(&mut out, "    offset += {};", field.primitive.byte_len()).unwrap();
    }
    out.push_str("    return true;\n}\n\n");

    out
}

fn primitive_encode_stmt(
    primitive: PrimitiveType,
    endian: Endian,
    source: &str,
    dest_ptr: &str,
    indent: &str,
) -> String {
    match primitive {
        PrimitiveType::Char | PrimitiveType::Int8 | PrimitiveType::Uint8 => format!(
            "{indent}({dest})[0] = (uint8_t)({src});\n",
            indent = indent,
            dest = dest_ptr,
            src = source
        ),
        PrimitiveType::Int16 => format!(
            "{indent}seridl_write_u16_{suffix}((uint16_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Uint16 => format!(
            "{indent}seridl_write_u16_{suffix}((uint16_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Int32 => format!(
            "{indent}seridl_write_u32_{suffix}((uint32_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Uint32 => format!(
            "{indent}seridl_write_u32_{suffix}((uint32_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Int64 => format!(
            "{indent}seridl_write_u64_{suffix}((uint64_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Uint64 => format!(
            "{indent}seridl_write_u64_{suffix}((uint64_t)({src}), {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Float32 => format!(
            "{indent}seridl_write_f32_{suffix}({src}, {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
        PrimitiveType::Float64 => format!(
            "{indent}seridl_write_f64_{suffix}({src}, {dest});\n",
            indent = indent,
            suffix = endian.suffix(),
            src = source,
            dest = dest_ptr
        ),
    }
}

fn primitive_decode_stmt(
    primitive: PrimitiveType,
    endian: Endian,
    dest: &str,
    src_ptr: &str,
    indent: &str,
) -> String {
    match primitive {
        PrimitiveType::Char => format!(
            "{indent}{dest} = (char)(({src})[0]);\n",
            indent = indent,
            dest = dest,
            src = src_ptr
        ),
        PrimitiveType::Int8 => format!(
            "{indent}{dest} = (int8_t)(({src})[0]);\n",
            indent = indent,
            dest = dest,
            src = src_ptr
        ),
        PrimitiveType::Uint8 => format!(
            "{indent}{dest} = (uint8_t)(({src})[0]);\n",
            indent = indent,
            dest = dest,
            src = src_ptr
        ),
        PrimitiveType::Int16 => format!(
            "{indent}{dest} = (int16_t)seridl_read_u16_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Uint16 => format!(
            "{indent}{dest} = seridl_read_u16_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Int32 => format!(
            "{indent}{dest} = (int32_t)seridl_read_u32_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Uint32 => format!(
            "{indent}{dest} = seridl_read_u32_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Int64 => format!(
            "{indent}{dest} = (int64_t)seridl_read_u64_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Uint64 => format!(
            "{indent}{dest} = seridl_read_u64_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Float32 => format!(
            "{indent}{dest} = seridl_read_f32_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
        PrimitiveType::Float64 => format!(
            "{indent}{dest} = seridl_read_f64_{suffix}({src});\n",
            indent = indent,
            dest = dest,
            suffix = endian.suffix(),
            src = src_ptr
        ),
    }
}

fn type_name(msg: &MessageDefinition) -> String {
    format!("seridl_msg_{}_t", to_snake_case(&msg.name))
}

fn encode_fn_name(msg: &MessageDefinition) -> String {
    format!("seridl_msg_{}_encode", to_snake_case(&msg.name))
}

fn decode_fn_name(msg: &MessageDefinition) -> String {
    format!("seridl_msg_{}_decode", to_snake_case(&msg.name))
}

fn header_guard_name(path: &Path) -> String {
    let file_name = path
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("generated_header");
    let mut guard = String::new();
    for ch in file_name.chars() {
        if ch.is_ascii_alphanumeric() {
            guard.push(ch.to_ascii_uppercase());
        } else {
            guard.push('_');
        }
    }
    if !guard.ends_with("_H") {
        if !guard.ends_with('_') {
            guard.push('_');
        }
        guard.push('H');
    }
    guard
}
